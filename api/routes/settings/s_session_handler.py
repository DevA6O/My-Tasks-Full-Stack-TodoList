import logging
from uuid import UUID
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.responses import JSONResponse
from sqlalchemy import update
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel

from security.jwt import get_bearer_token, decode_token
from shared.decorators import validate_params
from database.connection import get_db
from database.models import Auth

router = APIRouter()
logger = logging.getLogger(__name__)

class SettingSessionsHandler:
    @validate_params
    def __init__(self, jti_id: UUID, current_token: str, db_session: AsyncSession) -> None:
        # Validate params
        if not isinstance(jti_id, UUID):
            raise TypeError("jti_id must be an UUID.")
        
        if not isinstance(current_token, str):
            raise TypeError("current_token must be a string.")

        self.jti_id: UUID = jti_id
        self.token: str = current_token
        self.db_session: AsyncSession = db_session

    def _is_session_match(self) -> bool:
        """ Checks whether the access token was generated by the same refresh token that is to be logged out.

        Returns:
        --------
            - A boolean: Optimal, if the two IDs do not match, False is returned, otherwise an HTTPException.

        Raises:
        -------
            - A HTTPException: If the refresh token matches the information from the access token
        """
        payload: dict = decode_token(token=self.token)
        session_id: str = payload.get("session_id")

        if not session_id:
            raise ValueError("session_id must be not None.")
        
        if str(self.jti_id) == str(session_id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, 
                detail="You cannot end the current session yourself. Please log out instead."
            )
        
        return False

    async def revoke(self) -> bool:
        """ Invalidates the token 
        
        Returns:
        --------
            - A boolean
        """
        if not self._is_session_match():
            stmt = update(Auth).where(Auth.jti_id==self.jti_id).values(revoked=True)
            result = await self.db_session.execute(stmt)

            if result.rowcount > 0:
                await self.db_session.commit()
                return True
        
        return False


class SessionID(BaseModel):
    """ Validator for jti_id """

    jti_id: str


@router.post("/session/revoke")
async def settings_revoke_session_endpoint(
    payload: SessionID, token: str = Depends(get_bearer_token), db_session: AsyncSession = Depends(get_db) 
) -> JSONResponse:
    try:
        handler = SettingSessionsHandler(jti_id=UUID(payload.jti_id), current_token=token, db_session=db_session)
        result = await handler.revoke()

        if result:
            return JSONResponse(
                status_code=status.HTTP_200_OK,
                content={"message": "The device has been successfully logged out."}
            )
    except TypeError as e:
        logger.exception(str(e), exc_info=True)

    raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail="The device could not be logged out."
    )